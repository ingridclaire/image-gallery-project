import { useState, useEffect } from "react";
import { CategoryContainer } from "./category-styles";
import { useParams } from "react-router-dom";
import { after } from "underscore";
import { NavLink } from "../navigation/navigation-styles";
import { ART } from "../../assets/ART_DATA.js";
import ArtPiece from "../../components/art-piece/art-piece-component.jsx";
import "./category-styles.css";

//Two questions:  how would I change directory-component.jsx page to static and how would I change art-piece-component to responsive?
// ICC: I'm not sure what you mean by "change directory-component.jsx page to static". If you mean static like there will be no re-renders necessary, you could do that by removing the state and useEffect hooks and just hardcoding the data into the component. If you mean something else, please clarify. As for making the art-piece-component responsive, you could use CSS media queries to adjust the layout of the component based on the screen size. You could also use a CSS framework like Bootstrap to help with responsiveness.

export default function Category() {
  let artPiecesOfCategoryArray = [];
  const route = useParams();
  let imageCategoryToShow = route.category;
  let [products, setProducts] = useState(ART);
  // ICC: it's not necessary to define artPiecesOfCategoryArray on line 14 and then reassign here on 19. You can just define it here on 19. So, just delete line 14 and add const in front of line 19.
  artPiecesOfCategoryArray = products.filter(
    (element) => element.category === imageCategoryToShow
  );
  useEffect(() => {
    const productsArrayStored = JSON.parse(localStorage.getItem("products"));
    const panelsArrayStored = JSON.parse(localStorage.getItem("panel"));
    if (productsArrayStored) {
      setProducts(productsArrayStored);
    }
    if (panelsArrayStored) {
      setPanelInformation(panelsArrayStored);
    }
  }, []);
  // ICC this onComplete function is not doing anything, so you can remove it or modify the callback to do something
  const onComplete = after(products.length, () => {});
  // ICC move all your state variables to the same area, generally at the top of the component (inside the function), like after you defined products state.
  let [panelInformation, setPanelInformation] = useState([]);
  // ICC similarly, keep all your useEffect calls together
  // ICC this useEffect is not doing anything, so you should delete it
  useEffect(() => {}, []);
  // ICC move this state to top with other states
  let [showPanel, setShowPanel] = useState(false);
  //amount of cjecks is what was selected from that interface

  // ICC there is quite a bit of redundancy in this function setPanelInfo as well as in setPanelElement, but I may not be aware of all what you are using it for. I'm guessing there is a more efficient way to do what you need in a more "react" way that we could discuss.
  //ICC since you have a state variable called panelInformation and its setter, setPanelInformation, I'd name this function something different than setPanelInfo, since it's not setting the state variable in most cases, it's just using it. Maybe something like updatePanelInfo or something like that. In react when a function starts with "set" it's generally assumed to be a function that sets state, and that is generated by the useState hook.
  const setPanelInfo = (amtountOfChecks, product) => {
    // ICC the following two variables are not used, so you should remove them
    let panelInformationListLeftElements = [];
    let panelArrayWithDeletedElement = [];
    // ICC I would use a switch case here instead of if else if since you are checking the same variable in each case
    // ICC I would also use the cases to create the object you are passing to setPanelElement (assuming you refactor setPanelElement to accept an object instead of multiple separate parameters), so you don't have to repeat the same code in each case. Then you can just call setPanelElement with the object as an argument after the switch case. This will reduce redundancy and make the code easier to read and maintain.
    if (amtountOfChecks == 1) {
      setPanelElement(
        product.id,
        product.name,
        product.imageUrl,
        product.price,
        true,
        false,
        false,
        false,
        product.category,
        "One Check"
      );
    } else if (amtountOfChecks == 2) {
      setPanelElement(
        product.id,
        product.name,
        product.imageUrl,
        product.price,
        true,
        false,
        false,
        false,
        product.category,
        "Two Checks"
      );
    } else if (amtountOfChecks == 3) {
      setPanelElement(
        product.id,
        product.name,
        product.imageUrl,
        product.price,
        true,
        false,
        false,
        false,
        product.category,
        "Three Checks"
      );
    } else if (amtountOfChecks == 4) {
      setPanelElement(
        product.id,
        product.name,
        product.imageUrl,
        product.price,
        true,
        false,
        false,
        false,
        product.category,
        "Four Checks"
      );
    } else {
      let arrayWithoutElement = panelInformation.filter(
        (panelElement) => panelElement.id != product.id
      );
      setPanelInformation(arrayWithoutElement);
      localStorage.setItem(`panel`, JSON.stringify(arrayWithoutElement));
    }
  };

  //keep art pieces organized using there id for panel
  // ICC I'd want to investigate the purpose and need for this function if some of my suggestion about refactoring the way to do checkmarks in the computeChecks function were implemented. This may not be needed.
  function redistributeTheIds(id, panelInformation) {
    // ICC following 2 variables are not used so should be deleted
    let currentid = -1;
    let missingIDIndex = -1;
    let arrayOfIDS = [];
    for (let i = 0; i < panelInformation.length; i++) {
      let IDVariable = panelInformation[i].id;
      arrayOfIDS[i] = IDVariable;
    }
    return arrayOfIDS;
  }

  //ICC would be cleaner to have this function just accept an object with properties for each of these parameters. doing it this way means you must always pass in arguments in the exact correct order, where as if you passed in an object, the properties in the object can be in any order. Less prone to error.So, the function would only have one parameter, and this shape of the parameter would be this: {id, name, url, price, option1, option2, option3, option4, category, amountstars}
  const setPanelElement = (
    id,
    name,
    url,
    price,
    option1,
    option2,
    option3,
    option4,
    category,
    amountstars
  ) => {
    /* ICC you could refactor this function to accept an object as a parameter and then use the spread operator to copy over the properties of that object to the new object you are creating, and only modify properties that need to be changed like this:
    let panelInformationElementToAdd = {
    ...objectPassedIn, 
    imageUrl: url, 
    options: [
      { option: "option1", checked: option1 },
      { option: "option2", checked: option2 },
      { option: "option3", checked: option3 },
      { option: "option4", checked: option4 },
    ],
    amtstars: amountstars,
  }
    this change removes redundancy and makes the code easier to read and maintain.
    */
    let panelInformationElementToAdd = {
      id: id,
      name: name,
      imageUrl: url,
      price: price,
      options: [
        { option: "option1", checked: option1 },
        { option: "option2", checked: option2 },
        { option: "option3", checked: option3 },
        { option: "option4", checked: option4 },
      ],
      category: category,
      amtstars: amountstars,
    };
    let panelInformation2 = panelInformation.filter(
      (panelElement) => panelElement.id === id
    );
    //there are no elements in array for panel with this new info
    if (panelInformation2.length == 0) {
      let arrayFOrPanel = [...panelInformation, panelInformationElementToAdd];
      setPanelInformation(arrayFOrPanel);
      localStorage.setItem(`panel`, JSON.stringify(arrayFOrPanel));
    } else {
      ///there is an element with this check, and stars have changed
      let arrayOfIDs = [];
      const panelInformationChanged = panelInformation.map((pan, index) => {
        arrayOfIDs = redistributeTheIds(id, panelInformation);
        let indexOfElement = arrayOfIDs[index];
        if (indexOfElement === id) {
          return panelInformationElementToAdd;
        } else {
          return pan;
        }
      });
      setPanelInformation(panelInformationChanged);
      localStorage.setItem(`panel`, JSON.stringify(panelInformationChanged));
    }
  };

  //Sets one element of another array with checks
  // ICC rename this function to not start with "set" since it's not setting state, it's just updating an element in an array. Maybe something like updateCheckboxes or something like that.
  //ICC bigger picture: this may not be needed if the way you are doing checkmarks is refactored as I suggested in the computeChecks function.
  const setCheckboxes = (check1, check2, check3, check4, infoArray, id) => {
    infoArray[id].options[0].checked = check1;
    infoArray[id].options[1].checked = check2;
    infoArray[id].options[2].checked = check3;
    infoArray[id].options[3].checked = check4;
    return infoArray;
  };

  //makes display ordered by index using elements id
  // ICC this function will not be necessary with the refactor I suggested in the computeChecks function
  const advanceToNextID = (productIDToAdvance) => {
    let index = 0;
    let j = 1;
    while (productIDToAdvance != products[index].id) {
      index++;
    }
    return index;
  };

  /* ICC this function is doing a lot of work and could be broken up into smaller functions to make it easier to read and understand
  1. don't make the event obejct (e) a parameter for this function, rather in the component where this function is used, set up a changeHandler and that function can have e as a paramter, and also can invoke this computerChecks function.
  2. I would probably approach the checks computation quite a bit differently: update the data so that each product has a property for the number of stars/checks it has, and then you can just update that property when a checkbox is checked/unchecked. This way you don't have to check the state of each checkbox to determine how many stars are checked. You can just check the value of the property on the product object.Then, in the jsx where you are displaying the checkboxes, you can just check the value of the property on the product object to determine if the checkbox should be checked or not. We can discuss further in a call if helpful. After this refactor, computeChecks would only need to get the id of the artpiece and the number of stars to set on it.Then you can use map to find the correct art piece and update the number of stars on it. This would be a much more "react" way to do this.
  */
  const computeChecks = (e, indexOfCheckBoxes, howManyChecked, product) => {
    let productIndex = advanceToNextID(product.id);
    let infoArray = [...products];
    let checked = e.target.checked;
    let amtStars = 0;
    //index of four stars satring at zero
    indexOfCheckBoxes = indexOfCheckBoxes - 1;
    ///product.id = product.id - 1;
    //index is which star, zero through three
    //infoarray was set to products above, in this function
    //how the check boxes work:
    //for any checked box, all boxes before this box will be checked
    //reclicking on a checked box will result in that box and all boxes to the right to be unchecked and the left to be checked.////////
    //check boxes start all false
    //appply to first box
    if (indexOfCheckBoxes === 0) {
      //all check boxes start as false
      //if there is a check on second box and than box one is checked, the check will result in box one being checked
      if (infoArray[productIndex].options[1].checked == true) {
        amtStars = 1;
        setCheckboxes(true, false, false, false, infoArray, productIndex);
      }
      //all check boxes start as false
      //apply check to second box
      //check box one is checked and than index checks one.  so, results in no checks
      else if (infoArray[productIndex].options[0].checked == true) {
        amtStars = 0;
        setCheckboxes(false, false, false, false, infoArray, productIndex);
      } else {
        amtStars = 1;
        //all check boxes start as false
        //apply check to second box
        //three falses,  so it will be a simple check on first box
        setCheckboxes(true, false, false, false, infoArray, productIndex);
      }
    }
    //check boxes start all false
    //apply check to second box
    if (indexOfCheckBoxes === 1) {
      if (infoArray[productIndex].options[2].checked == true) {
        // product.id = product.id - 1;
        amtStars = 2;
        //all check boxes start as false
        //if third box is true and box two is than checked there will be two stars
        setCheckboxes(true, true, false, false, infoArray, productIndex);
      }
      //all check boxes start as false
      //if second box is false and box two is than starred, there will be two stars
      else if (infoArray[productIndex].options[1].checked == false) {
        amtStars = 2;
        setCheckboxes(true, true, false, false, infoArray, productIndex);
      }
      //all check boxes start as false
      //isn't checked on third box and is checked on second box (using else)
      //box two is than changed with index that reverts box two to false
      else {
        amtStars = 0;
        setCheckboxes(false, false, false, false, infoArray, productIndex);
      }
    }
    //all check boxes start as false
    //apply check to third box
    if (indexOfCheckBoxes === 2) {
      //all check boxes start as false
      //if box four is checked, and three is checked with index, there will be three checks
      if (infoArray[productIndex].options[3].checked == true) {
        amtStars = 3;
        setCheckboxes(true, true, true, false, infoArray, productIndex);
      }
      //all check boxes start as false
      //if box three is checked and index is applied with third box, all false
      else if (infoArray[productIndex].options[2].checked == true) {
        amtStars = 0;
        setCheckboxes(false, false, false, false, infoArray, productIndex);
      } else {
        //all check boxes start as false
        //by negation of above, fourth star is false, and and third check is false
        //index applied, three trues and a false
        amtStars = 3;
        setCheckboxes(true, true, true, false, infoArray, productIndex);
      }
    }
    //all check boxes start as false
    //apply check to fourth box
    if (indexOfCheckBoxes === 3) {
      //all check boxes start as false
      //index is three so will be all stars, all stars with last element checked with index will be all false
      if (infoArray[productIndex].options[3].checked == true) {
        amtStars = 0;
        setCheckboxes(false, false, false, false, infoArray, productIndex);
      }
      //all check boxes start as false
      //there is a check on fourth box, so is all true.
      else {
        amtStars = 4;
        setCheckboxes(true, true, true, true, infoArray, productIndex);
      }
    }
    setProducts(infoArray);
    // ICC var1 is never used, should be removed
    let var1 = JSON.parse(localStorage.getItem("products"));
    setPanelInfo(amtStars, product);
    localStorage.setItem(`products`, JSON.stringify(infoArray));
  };
  return (
    <div>
      <div className="artwork-title">Would you like to rate these works?</div>
      <div className="buttonShow">
        <button
          // ICC this onClick can be put on one line like:
          // onClick={() => setShowPanel((showPanel) => !showPanel)}
          onClick={() => {
            //
            setShowPanel((showPanel) => !showPanel);
          }}
        >
          {/* ICC you can use a ternary operator to change the text of this button between "Show Panel" and "Hide Panel" ie when showPanel is false the text says "Show Panel" and when it's true the text says "Hide Panel" */}
          Show Panel
        </button>
      </div>
      <div className="artwork-link">
        <NavLink to="/">Home Page</NavLink>
      </div>
      <CategoryContainer>
        {artPiecesOfCategoryArray.map((product) => (
          // Display artwork in this mapped component
          // ICC great job refactoring this to use the ArtPiece component!
          <ArtPiece
            key={product.imageUrl}
            product={product}
            onComplete={onComplete}
            computeChecks={computeChecks}
            showPanel={showPanel}
            panelInformation={panelInformation}
            setShowPanel={setShowPanel}
          />
        ))}
      </CategoryContainer>
    </div>
  );
}
